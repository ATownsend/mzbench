<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Workers - MZBench Docs</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/custom.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">MZBench Docs</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Overview</a>
                    </li>
                
                
                
                    <li >
                        <a href="../scenarios/">Scenarios</a>
                    </li>
                
                
                
                    <li >
                        <a href="../server_api/">Server API</a>
                    </li>
                
                
                
                    <li >
                        <a href="../deployment_guide/">Deployment</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Workers</a>
                    </li>
                
                
                
                    <li >
                        <a href="../cloud_plugin/">Cloud Plugins</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../deployment_guide/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../cloud_plugin/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="http://github.com/machinezone/mzbench/">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#how-to-write-a-worker">How to Write a Worker</a></li>
        
            <li><a href="#command-line-utilities">Command line utilities</a></li>
        
            <li><a href="#general-worker-structure">General worker structure</a></li>
        
            <li><a href="#how-to-define-statements">How to define statements</a></li>
        
            <li><a href="#metrics">Metrics</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p>Today internet is a huge set of ever changing technologies. It would be impossible in practice for MZBench distribution to provide an extensive library of functions to access all the possible services and protocols. Instead, it uses a plugin system called <em>workers</em>.</p>
<p>A <em>worker</em> is an Erlang application providing a set of MZBench DSL statements to access a particular service (such as HTTP or SSH server) and collecting a set of statistics about its usage. A small set of standard <em>workers</em> is provided with the distribution, but you will likely need to write your own to access the service you want to benchmark. This document is here to guide you through this process.</p>
<p>Because a MZBench <em>worker</em> is an Erlang application, you need some basic knowledge of this programming language to understand this document. You can refer yourself to <a href="http://www.erlang.org/doc/getting_started/users_guide.html">Getting Started with Erlang User&rsquo;s Guide</a> or to the <a href="http://learnyousomeerlang.com">Learn You Some Erlang for great good!</a> book for an introduction to the matter.</p>
<h1 id="how-to-write-a-worker">How to Write a Worker<a class="headerlink" href="#how-to-write-a-worker" title="Permanent link">&para;</a></h1>
<h2 id="command-line-utilities">Command line utilities<a class="headerlink" href="#command-line-utilities" title="Permanent link">&para;</a></h2>
<p>MZBench distribution provide some command line utilities to assist you during your <em>worker</em> development effort.</p>
<h3 id="new-worker-generation">New worker generation<a class="headerlink" href="#new-worker-generation" title="Permanent link">&para;</a></h3>
<p>First of all, you can generate an empty <em>worker</em> application using the following command (here and later <code>&lt;MZBENCH_SRC&gt;</code> means the path to the MZBench source code):</p>
<pre><code>&lt;MZBENCH_SRC&gt;/bin/mzbench new_worker &lt;worker_name&gt;
</code></pre>
<p>This will create a new directory <code>&lt;worker_name&gt;</code> containing a minimalistic, but fully functional MZBench <em>worker</em> named <code>&lt;worker_name&gt;</code>. Particularly interesting generated files are <code>src/&lt;worker_name&gt;.erl</code> containing the <em>worker</em> source code and <code>examples/&lt;worker_name&gt;.erl</code> containing a simple MZBench scenario using it.</p>
<p>If the service you want to access is based on some well known protocol, such as TCP, the <code>new_worker</code> command can generate your a more elaborate <em>worker</em> already containing the usual boilerplate code for this type of service. You can obtain a list of available protocols by executing:</p>
<pre><code>&lt;MZBENCH_SRC&gt;/bin/mzbench list_templates
</code></pre>
<p>Then generate your <em>worker</em> by adding an additional parameter to the <code>new_worker</code> command:</p>
<pre><code>&lt;MZBENCH_SRC&gt;/bin/mzbench new_worker --template &lt;protocol&gt; &lt;worker_name&gt;
</code></pre>
<h3 id="worker-compilation-and-debugging">Worker compilation and debugging<a class="headerlink" href="#worker-compilation-and-debugging" title="Permanent link">&para;</a></h3>
<p>During any serious development, you will certainly need a to do a lot of debugging. If every time you want to launch your test scenario you would need to commit your <em>worker</em> to a remote Git repository and to launch a complete benchmark, it would be cumbersome. So MZBench provide you with a way to quickly build your worker and launch a local instance of your benchmarking scenario using it.</p>
<p>Inside your <em>worker</em> source code directory (the root one, not the <code>src</code>), execute the following command replacing <code>&lt;script&gt;</code> by the path to the benchmarking scenario you want to run:</p>
<pre><code>&lt;MZBENCH_SRC&gt;/bin/mzbench run_local &lt;script&gt;
</code></pre>
<p>You can pass the environment variables using the <code>--env</code> option. But, please note that all <code>make_install</code> top-level statements will be ignored in this execution mode.</p>
<h3 id="worker-execution">Worker execution<a class="headerlink" href="#worker-execution" title="Permanent link">&para;</a></h3>
<p>After you have done with debugging, you need to execute your worker in a cloud. To do that, you need to specify worker git address at your benchmark script with <code>{make_install, [{git, &lt;URL&gt;}, {branch, &lt;Branch&gt;}, {dir, &lt;Dir&gt;}]}</code>, <a href="../../workers/simple_http/examples/simple_http.erl">http worker example</a>.</p>
<h2 id="general-worker-structure">General worker structure<a class="headerlink" href="#general-worker-structure" title="Permanent link">&para;</a></h2>
<p>An MZBench <em>worker</em> provides a set of DSL statements (i.e. sub-routines) and a set of metrics. The different sub-routines need not to be independent as the worker can have internal state.</p>
<p>To understand the general structure of a <em>worker</em>, let see the source code of the <code>dummy_worker</code> provided with the MZBench distribution:</p>
<pre><code>-module(dummy_worker).
-export([initial_state/0, metrics/0,
         print/3]).

-include("mzb_types.hrl").

-type state() :: string().
-type meta() :: [{Key :: atom(), Value :: any()}].

-type graph_group() :: {group, Name :: string(), [graph()]}
                     | graph().
-type graph()       :: {graph, Opts :: #{metrics =&gt; [metric()],
                                         units =&gt; string(),
                                         title =&gt; string()}}
                     | [metric()]
                     | metric().
-type metric()      :: {Name :: string(), Type :: metric_type() }
                     | {Name :: string(), Type :: metric_type(), Opts :: map() }.
-type metric_type() :: counter | gauge | histogram.

-spec initial_state() -&gt; state().
initial_state() -&gt; [].

-spec metrics() -&gt; [graph_group()].
metrics() -&gt; [{group, "Application Metrics", [
                {graph, #{ title =&gt; "Dummy counter",
                           units =&gt; "budger",
                           metrics =&gt; [{"dummy_counter", counter}]}}
             ]}].

-spec print(state(), meta(), string()) -&gt; {nil, state()}.
print(State, Meta, Text) -&gt;
    mzb_metrics:notify({"dummy_counter", counter}, 1),
    lager:info("Printing ~p, Meta: ~p~n", [Text, Meta]),
    {nil, State}.
</code></pre>
<p>As can be seen, it export&rsquo;s 3 functions: <code>initial_state/0</code>, <code>metrics/0</code> and <code>print/3</code>. First two of them are mandatory for any <em>worker</em>. </p>
<p><code>initial_state/0</code> function can return anything and is used to initialize the <em>worker</em> initial state. Each parallel execution job have its own state, so this function will be called once per job start.</p>
<p><code>metrics/0</code> function is also mandatory. It return a group of metrics generated by this <em>worker</em>. Please refer yourself to <a href="#how-to-define-metrics">How to define metrics</a> for further reference concerning this function.</p>
<p>All the remaining exported functions defines the DSL statements provided by this <em>worker</em>. You can, of course, provide none, although such a <em>worker</em> wouldn&rsquo;t be very useful. The <code>dummy_worker</code>, for instance, provide the <code>print</code> statement useful to output some string of characters to the standard output. Refer yourself to <a href="#how-to-define-statements">How to define statements</a> for a more detailed discussion on this topic.</p>
<h2 id="how-to-define-statements">How to define statements<a class="headerlink" href="#how-to-define-statements" title="Permanent link">&para;</a></h2>
<p>To define a DSL statement provided by your <em>worker</em> you export an Erlang function that will be called when such a statement is encountered. The exported function is of the following general form:</p>
<pre><code>&lt;statement_name&gt;(State, Meta, [&lt;Param1&gt;, [&lt;Param2&gt;, ...]]) -&gt;
    {ReturnValue, NewState}.
</code></pre>
<p>The function must have the same name as the statement it defines. It must take at least two parameters: the <em>worker</em> internal state at the moment the statement is executed and <em>meta</em> information proplist. The function can also accept any number of other parameters. They correspond to the parameters of the statement.</p>
<p>The statement function must return a tuple of two values. The first one is the return value of statement. You must return <code>nil</code> if your statement has no return value. The second member of the tuple is the next <em>worker</em> state. Each statement is processed sequentially and using previous state except internal statements of {parallel} section and iterations within a loop having parallel &gt; 1. In these cases statements within the same thread will share one sequence of statements and other parallel threads wont. Final state of the whole {parallel} or {loop} statement will be the very first one (from the first &ldquo;thread&rdquo;), other thread&rsquo;s states will not affect the final one.</p>
<p>For example, the following function:</p>
<pre><code>foo(State, Meta, X, Y) -&gt;
    {nil, State}.
</code></pre>
<p>Can be called as <code>{foo, X, Y}</code> from a benchmarking scenario.</p>
<h2 id="metrics">Metrics<a class="headerlink" href="#metrics" title="Permanent link">&para;</a></h2>
<p>Metrics are numerical values collected during the scenario execution. They are the main result of your <em>worker</em> and represent the values you want to evaluate with your benchmark.</p>
<h3 id="metric-types">Metric types<a class="headerlink" href="#metric-types" title="Permanent link">&para;</a></h3>
<p>The MZBench currently support three types of metrics:</p>
<ul>
<li><code>counter</code> - A single additive value. New values are simply added to the current one.</li>
<li><code>gauge</code> - A single non additive value. New value replaces the previous one.</li>
<li><code>histogram</code> - A set of numerical values that quantify a distribution of values. New values are added to the distribution.</li>
<li><code>derived</code> - metric value is evaluated periodically using user defined function based on other metric values (see <a href="#derived-metrics">Derived metrics</a> for more details).</li>
</ul>
<p>For example, if you are consuming TCP packets of various sizes and you want to track overall amount of data being transferred — you need <code>counter</code> and if you are interested in its distribution: mean size, 50 percentile and so on — you need a <code>histogram</code>.</p>
<h3 id="declaring-metrics">Declaring metrics<a class="headerlink" href="#declaring-metrics" title="Permanent link">&para;</a></h3>
<p>You declare the groups of metrics collected by your <em>worker</em> in the list returned by the <code>metrics/0</code> function. Each group corresponds to a structure with following spec:</p>
<pre><code>graph_group() :: {group, Name :: string(), [graph()]}
               | graph().
graph()       :: {graph, Opts :: #{metrics =&gt; [metric()],
                                   units =&gt; string(),
                                   title =&gt; string()}}
               | [metric()]
               | metric().
metric()      :: {Name :: string(), Type :: metric_type() }
               | {Name :: string(), Type :: metric_type(), Opts :: map()}.
metric_type() :: counter | gauge | histogram.
</code></pre>
<p>This structure supports a three-level hierarchy:</p>
<ul>
<li>Group of graphs is placed on the top of this hierarchy. It consists of the one or more graphs and define a group of graphs under the same name.</li>
<li>Graph consists of the one or more metrics that will be plotted on the same chart. Furthermore, you could specify additional option for the chart (e.g. units, title etc)</li>
<li>Metric is the lowest unit of this hierarchy. It specifies the name and type of the user-defined metric.</li>
</ul>
<p>Let see the following metrics declaration:</p>
<pre><code>metrics() -&gt; [{group, "HTTP Requests", [
                {graph, #{metrics =&gt; [{"success_requests", counter}, {"failed_requests", counter}]}},
                {graph, #{title =&gt; "Request's latency",
                          units =&gt; "ms",
                          metrics =&gt; [{"latency", histogram}]}}]}].
</code></pre>
<p>In this example, a group of graphs with name &ldquo;HTTP Requests&rdquo; will be created. It will consist of the several graphs presented the number of success/failed requests and the request&rsquo;s latencies. Please note then a graph could produce several charts. In the mentioned example, the graph for success and failed request will produce two charts: absolute counters and their rps.</p>
<h3 id="derived-metrics">Derived metrics<a class="headerlink" href="#derived-metrics" title="Permanent link">&para;</a></h3>
<p>Derived metrics are basically gauges which are evaluated on the director node every ~10sec. To define a derived metric &ldquo;resolver&rdquo; function should be specified in metric opts dictionary. Resolver function is used to evaluate metric value.
Typical example of the derived metrics is the current number of pending requests. We specify a function (pending_requests) to calculate the metric value in metrics options and then define the function as simple difference between number of sent requests and number of reeived responses:</p>
<pre><code>metrics() -&gt; [{group, "Requests", [
                {graph, #{metrics =&gt; [
                    {"requests_sent", counter},
                    {"responses_received", counter},
                    {"pending_requests", derived, #{resolver =&gt; pending_requests}}]}},
                ]}].

pending_requests() -&gt;
    mzb_metrics:get_value("requests_sent") - mzb_metrics:get_value("responses_received").
</code></pre>
<h3 id="hooks">Hooks<a class="headerlink" href="#hooks" title="Permanent link">&para;</a></h3>
<p>Pre and post hooks allow to run a custom code before or after benchmark. Hooks could be applied on every nodes or on the director node only. You are able to change any environment variable in your hook handler and use it in your scenario.</p>
<p>Scenario:</p>
<pre><code>{pre_hook, [
    {exec, all, "yum install zlib"},
    {worker_call, fetch_commit, my_worker}
]}

{pool, [{size, 3}, {worker_type, dummy_worker}], [
    {loop, [{time, {1, sec}},
            {rate, {ramp, linear, {10, rps}, {50, rps}}}],
        [{print, {var, "commit", "default"}}]}]},
</code></pre>
<p>Worker:</p>
<pre><code>fetch_commit(Env) -&gt;
    {ok, [{"commit", "0123456"} | Env]}.
</code></pre>
<h3 id="updating-metrics">Updating metrics<a class="headerlink" href="#updating-metrics" title="Permanent link">&para;</a></h3>
<p>You can update a declared metric from anywhere inside your <em>worker</em>. Simply call the following function:</p>
<pre><code>mzb_metrics:notify({"&lt;metric_name&gt;", &lt;metric_type&gt;}, &lt;value&gt;)
</code></pre>
<p>The tuple <code>{"&lt;metric_name&gt;", &lt;metric_type&gt;}</code> is the same that was used during the metric declaration and identifies the metric to update. The <code>&lt;value&gt;</code> is the value to add to the metric.</p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
